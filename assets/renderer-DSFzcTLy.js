const ot={chrome:268435456,firefox:1073676289,safari:16777216,default:16777216};function at(){const t=navigator.userAgent.toLowerCase();return t.includes("chrome")||t.includes("edge")?"chrome":t.includes("firefox")?"firefox":t.includes("safari")&&!t.includes("chrome")?"safari":"default"}function it(){const t=at();return ot[t]}function ct(t,a){const e=it(),n=t*a;if(n>e){const r=at(),d=Math.floor(Math.sqrt(e));throw new Error(`Canvas size ${t}x${a} (${n.toLocaleString()} pixels) exceeds ${r} limit of ${Math.floor(Math.sqrt(e))}x${Math.floor(Math.sqrt(e))} (${e.toLocaleString()} pixels). Maximum dimension: ${d}px.`)}}function ht(){try{return typeof OffscreenCanvas<"u"&&typeof OffscreenCanvas.prototype.convertToBlob=="function"}catch{return!1}}function dt(t,a){if(ct(t,a),ht()){const e=new OffscreenCanvas(t,a),n=e.getContext("2d");if(!n)throw new Error("Failed to get 2D context from OffscreenCanvas");return{canvas:e,ctx:n}}else{const e=document.createElement("canvas");e.width=t,e.height=a;const n=e.getContext("2d");if(!n)throw new Error("Failed to get 2D context from Canvas");return{canvas:e,ctx:n}}}async function lt(t,a="image/png",e){return t instanceof OffscreenCanvas?t.convertToBlob({type:a,quality:e}):new Promise((n,r)=>{t.toBlob(d=>{d?n(d):r(new Error("Failed to convert canvas to blob"))},a,e)})}function mt(t){return/^#([0-9a-fA-F]{3}){1,2}$/.test(t)}class D extends Error{constructor(a,e,n){super(a),this.flagId=e,this.field=n,this.name="FlagValidationError"}}function ft(t){if(!t.pattern)throw new D(`Flag "${t.id}" is missing pattern data`,t.id,"pattern");if(!t.pattern.stripes||!Array.isArray(t.pattern.stripes))throw new D(`Flag "${t.id}" pattern is missing stripes array`,t.id,"pattern.stripes");if(t.pattern.stripes.length<1)throw new D(`Flag "${t.id}" must have at least 1 stripe, got ${t.pattern.stripes.length}`,t.id,"pattern.stripes");if(t.pattern.stripes.length>50)throw new D(`Flag "${t.id}" has too many stripes (${t.pattern.stripes.length}), maximum is 50`,t.id,"pattern.stripes");if(t.pattern.stripes.forEach((a,e)=>{if(!a.color)throw new D(`Flag "${t.id}" stripe ${e} is missing color`,t.id,`pattern.stripes[${e}].color`);if(!mt(a.color))throw new D(`Flag "${t.id}" stripe ${e} has invalid hex color: "${a.color}"`,t.id,`pattern.stripes[${e}].color`);if(typeof a.weight!="number")throw new D(`Flag "${t.id}" stripe ${e} is missing weight`,t.id,`pattern.stripes[${e}].weight`);if(a.weight<=0)throw new D(`Flag "${t.id}" stripe ${e} has non-positive weight: ${a.weight}`,t.id,`pattern.stripes[${e}].weight`);if(!Number.isFinite(a.weight))throw new D(`Flag "${t.id}" stripe ${e} has non-finite weight: ${a.weight}`,t.id,`pattern.stripes[${e}].weight`)}),!t.pattern.orientation)throw new D(`Flag "${t.id}" pattern is missing orientation`,t.id,"pattern.orientation");if(t.pattern.orientation!=="horizontal"&&t.pattern.orientation!=="vertical")throw new D(`Flag "${t.id}" pattern has invalid orientation: "${t.pattern.orientation}"`,t.id,"pattern.orientation")}class gt{startTime=0;marks=new Map;start(){this.startTime=performance.now(),this.marks.clear()}mark(a){this.marks.set(a,performance.now())}elapsed(){return performance.now()-this.startTime}duration(a,e){const n=this.marks.get(a),r=this.marks.get(e);return n===void 0||r===void 0?0:r-n}complete(a,e,n,r){const d=this.elapsed(),w=this.duration("start","imageLoaded"),u=this.duration("imageLoaded","renderComplete"),F=this.duration("renderComplete","exportComplete"),A=a.width*a.height*4,i=e.width*e.height*4,o=A+i;return{totalTime:d,imageLoadTime:w,renderTime:u,exportTime:F,inputSize:a,outputSize:e,wasDownsampled:n,downsampleRatio:r,estimatedMemory:o}}}function wt(t,a,e,n=2){const r=e*n;if(t<=r&&a<=r)return{width:t,height:a,scale:1};const d=Math.min(r/t,r/a);return{width:Math.round(t*d),height:Math.round(a*d),scale:d}}async function ut(t,a,e){if(t.width===a&&t.height===e)return t;const n=new OffscreenCanvas(a,e),r=n.getContext("2d");if(!r)throw new Error("Failed to get 2D context for downsampling");return r.imageSmoothingEnabled=!0,r.imageSmoothingQuality="high",r.drawImage(t,0,0,a,e),createImageBitmap(n)}function pt(t,a,e,n=2){return Math.max(t,a)>e*n}async function It(t,a,e){ft(a);const n=new gt,r=e.enablePerformanceTracking??!1;r&&(n.start(),n.mark("start"));const d=e.enableDownsampling??!0;let w=t,u=!1,F=1;if(d&&pt(t.width,t.height,e.size)){const c=wt(t.width,t.height,e.size);w=await ut(t,c.width,c.height),u=!0,F=c.scale,r&&n.mark("imageDownsampled")}r&&n.mark("imageLoaded"),e.onProgress?.(.2);const A=e.size,i=A,o=A,R=Math.min(i,o),Q=Math.round(e.thicknessPct/100*R),N=Math.round((e.paddingPct??0)/100*R),{canvas:K,ctx:s}=dt(i,o);e.backgroundColor&&(s.save(),s.fillStyle=e.backgroundColor,s.fillRect(0,0,i,o),s.restore());const m=Math.min(i,o)/2,b=m-Math.max(1,N),y=Math.max(0,b-Q),U=e.imageInsetPx??0,_=xt(y-U,0,m-.5),$=a.pattern.stripes,O=$.reduce((c,v)=>c+v.weight,0),S=e.presentation;let f;if(S==="ring"?f="concentric":S==="segment"?f="angular":S==="cutout"?f="cutout":f=a.pattern.orientation==="horizontal"?"concentric":"angular",f==="cutout"){s.save(),s.beginPath(),s.arc(m,m,_,0,Math.PI*2),s.closePath(),s.clip();const c=w.width,v=w.height,W=_*2,z=Math.max(W/c,W/v),B=c*z,E=v*z,X=i/2,Y=o/2;s.drawImage(w,X-B/2,Y-E/2,B,E),s.restore(),e.onProgress?.(.4);const p=e.flagOffsetPx?.x??e.imageOffsetPx?.x??0,T=Math.abs(p)*3,g=new OffscreenCanvas(i+T,o),h=g.getContext("2d");if(e.borderImageBitmap){const P=e.borderImageBitmap.width,l=e.borderImageBitmap.height,x=Math.max(g.width/P,g.height/l),M=P*x,I=l*x,C=(g.width-M)/2-p,q=(g.height-I)/2;h.drawImage(e.borderImageBitmap,C,q,M,I)}else if(a.pattern.orientation==="horizontal"){let P=0;for(const l of $){const M=l.weight/O*o;h.fillStyle=l.color,h.fillRect(0,P,g.width,M),P+=M}}else{let P=T/2-p;for(const l of $){const M=l.weight/O*i;h.fillStyle=l.color,h.fillRect(P,0,M,o),P+=M}}h.globalCompositeOperation="destination-in",h.fillStyle="white",h.beginPath(),h.arc(m+T/2,m,b,0,Math.PI*2),h.arc(m+T/2,m,y,Math.PI*2,0,!0),h.fill(),s.drawImage(g,-T/2,0)}else{s.save(),s.beginPath();const c=e.imageOffsetPx?.x??0,v=e.imageOffsetPx?.y??0;s.arc(m+c,m+v,_,0,Math.PI*2),s.closePath(),s.clip();const W=w.width,z=w.height,B=_*2,E=Math.max(B/W,B/z),X=W*E,Y=z*E,p=i/2+c,T=o/2+v;if(s.drawImage(w,p-X/2,T-Y/2,X,Y),s.restore(),e.onProgress?.(.5),e.borderImageBitmap&&S!=="cutout"){const g=Math.max(1,Math.round(b-y)),h=(y+b)/2,l=Math.max(2,Math.round(2*Math.PI*h)),x=g;try{const M=new OffscreenCanvas(l,x),I=M.getContext("2d"),C=e.borderImageBitmap.width,q=e.borderImageBitmap.height,G=Math.max(l/C,x/q),J=Math.round(C*G),Z=Math.round(q*G),H=Math.round((l-J)/2),nt=Math.round((x-Z)/2);I.clearRect(0,0,l,x),I.drawImage(e.borderImageBitmap,0,0,C,q,H,nt,J,Z);const rt=await createImageBitmap(M),st=-Math.PI/2;et(s,m,y,b,rt,st,"normal")}catch{try{et(s,m,y,b,e.borderImageBitmap)}catch{s.save(),s.globalAlpha=.64,tt(s,m,y,b,$,O),s.restore()}}}else if(f==="concentric")tt(s,m,y,b,$,O);else{let g=-Math.PI/2;for(const h of $){const P=h.weight/O,l=Math.PI*2*P,x=g+l;Mt(s,m,y,b,g,x,h.color),g=x}}}r&&n.mark("renderComplete"),e.onProgress?.(.8),e.outerStroke&&(s.beginPath(),s.arc(i/2,o/2,b,0,Math.PI*2),s.strokeStyle=e.outerStroke.color,s.lineWidth=e.outerStroke.widthPx,s.stroke());const k=e.pngQuality??.92,V=await lt(K,"image/png",k),L=V.size,j=(L/1024).toFixed(2);if(r){n.mark("exportComplete");const c=n.complete({width:t.width,height:t.height},{width:i,height:o},u,F);return e.onProgress?.(1),{blob:V,sizeBytes:L,sizeKB:j,metrics:c}}return e.onProgress?.(1),{blob:V,sizeBytes:L,sizeKB:j}}function tt(t,a,e,n,r,d){const w=n-e;let u=n;for(const F of r){const i=F.weight/d*w,o=Math.max(e,u-i);if(t.beginPath(),t.arc(a,a,u,0,Math.PI*2),t.arc(a,a,o,Math.PI*2,0,!0),t.closePath(),t.fillStyle=F.color,t.fill(),u=o,u<=e+.5)break}u>e+.5&&(t.beginPath(),t.arc(a,a,u,0,Math.PI*2),t.arc(a,a,e,Math.PI*2,0,!0),t.closePath(),t.fillStyle=r[r.length-1]?.color??"#000000",t.fill())}function Mt(t,a,e,n,r,d,w){t.beginPath(),t.arc(a,a,n,r,d),t.arc(a,a,e,d,r,!0),t.closePath(),t.fillStyle=w,t.fill()}function xt(t,a,e){return Math.min(Math.max(t,a),e)}function et(t,a,e,n,r,d=0,w="normal"){const u=n-e;if(u<=0)return;const F=(e+n)/2,A=Math.max(1,Math.round(2*Math.PI*F)),i=Math.max(1,A),o=Math.max(1,Math.round(u)),Q=new OffscreenCanvas(i,o).getContext("2d"),N=r.width,K=r.height,s=Math.max(i/N,o/K),m=Math.round(N*s),b=Math.round(K*s),y=Math.round((i-m)/2),U=Math.round((o-b)/2);Q.clearRect(0,0,i,o),Q.drawImage(r,0,0,N,K,y,U,m,b);const $=Q.getImageData(0,0,i,o).data,O=Math.floor(a-n),S=Math.floor(a-n),f=Math.ceil(n*2),k=f,V=new OffscreenCanvas(f,k),L=V.getContext("2d"),j=L.createImageData(f,k),c=j.data,v=Math.PI*2,W=1/v;for(let p=0;p<k;p++){const g=S+p+.5-a;for(let h=0;h<f;h++){const l=O+h+.5-a,x=l*l+g*g,M=Math.sqrt(x),I=(p*f+h)*4;if(M<e||M>n){c[I+0]=0,c[I+1]=0,c[I+2]=0,c[I+3]=0;continue}let C=Math.atan2(g,l);for(C-=d;C<0;)C+=v;for(;C>=v;)C-=v;const q=C*W*i,G=(M-e)/u*o,J=Math.min(i-1,Math.max(0,Math.floor(q))),H=(Math.min(o-1,Math.max(0,Math.floor(G)))*i+J)*4;c[I+0]=$[H+0],c[I+1]=$[H+1],c[I+2]=$[H+2],c[I+3]=$[H+3]}}if(L.putImageData(j,0,0),w==="normal"){t.save(),t.drawImage(V,O,S),t.restore();return}const z=new OffscreenCanvas(f,k),B=z.getContext("2d");B.clearRect(0,0,f,k),B.drawImage(t.canvas,O,S,f,k,0,0,f,k);const E=B.getImageData(0,0,f,k),X=E.data,Y=L.getImageData(0,0,f,k).data;for(let p=0;p<X.length;p+=4)Y[p+3]>8&&(X[p+3]=0);B.putImageData(E,0,0),t.save(),t.drawImage(z,O,S),t.restore()}export{It as r};
