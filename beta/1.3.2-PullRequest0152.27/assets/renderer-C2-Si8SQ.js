const ft={chrome:268435456,firefox:1073676289,safari:16777216,default:16777216};function rt(){const e=navigator.userAgent.toLowerCase();return e.includes("chrome")||e.includes("edge")?"chrome":e.includes("firefox")?"firefox":e.includes("safari")&&!e.includes("chrome")?"safari":"default"}function ht(){const e=rt();return ft[e]}function dt(e,a){const t=ht(),o=e*a;if(o>t){const s=rt(),m=Math.floor(Math.sqrt(t));throw new Error(`Canvas size ${e}x${a} (${o.toLocaleString()} pixels) exceeds ${s} limit of ${Math.floor(Math.sqrt(t))}x${Math.floor(Math.sqrt(t))} (${t.toLocaleString()} pixels). Maximum dimension: ${m}px.`)}}function gt(){try{return typeof OffscreenCanvas<"u"&&typeof OffscreenCanvas.prototype.convertToBlob=="function"}catch{return!1}}function ut(e,a){if(dt(e,a),gt()){const t=new OffscreenCanvas(e,a),o=t.getContext("2d");if(!o)throw new Error("Failed to get 2D context from OffscreenCanvas");return{canvas:t,ctx:o}}else{const t=document.createElement("canvas");t.width=e,t.height=a;const o=t.getContext("2d");if(!o)throw new Error("Failed to get 2D context from Canvas");return{canvas:t,ctx:o}}}async function wt(e,a="image/png",t){return e instanceof OffscreenCanvas?e.convertToBlob({type:a,quality:t}):new Promise((o,s)=>{e.toBlob(m=>{m?o(m):s(new Error("Failed to convert canvas to blob"))},a,t)})}const Pt={HIGH_RES:1024},bt={DEFAULT_CIRCLE_SIZE:250},Mt={BYTES_PER_KB:1024};class xt{startTime=0;marks=new Map;start(){this.startTime=performance.now(),this.marks.clear()}mark(a){this.marks.set(a,performance.now())}elapsed(){return performance.now()-this.startTime}duration(a,t){const o=this.marks.get(a),s=this.marks.get(t);return o===void 0||s===void 0?0:s-o}complete(a,t,o,s){const m=this.elapsed(),w=this.duration("start","imageLoaded"),d=this.duration("imageLoaded","renderComplete"),C=this.duration("renderComplete","exportComplete"),H=a.width*a.height*4,r=t.width*t.height*4,c=H+r;return{totalTime:m,imageLoadTime:w,renderTime:d,exportTime:C,inputSize:a,outputSize:t,wasDownsampled:o,downsampleRatio:s,estimatedMemory:c}}}function It(e,a,t,o=2){const s=t*o;if(e<=s&&a<=s)return{width:e,height:a,scale:1};const m=Math.min(s/e,s/a);return{width:Math.round(e*m),height:Math.round(a*m),scale:m}}async function Ct(e,a,t){if(e.width===a&&e.height===t)return e;const o=new OffscreenCanvas(a,t),s=o.getContext("2d");if(!s)throw new Error("Failed to get 2D context for downsampling");return s.imageSmoothingEnabled=!0,s.imageSmoothingQuality="high",s.drawImage(e,0,0,a,t),createImageBitmap(o)}function St(e,a,t,o=2){return Math.max(e,a)>t*o}async function yt(e,a,t){const o=new xt,s=t.enablePerformanceTracking??!1;s&&(o.start(),o.mark("start"));const m=t.enableDownsampling??!0;let w=e,d=!1,C=1;if(m&&St(e.width,e.height,t.size)){const i=It(e.width,e.height,t.size);w=await Ct(e,i.width,i.height),d=!0,C=i.scale,s&&o.mark("imageDownsampled")}s&&o.mark("imageLoaded"),t.onProgress?.(.2);const H=t.size,r=H,c=H,et=Math.min(r,c),N=Math.round(t.thicknessPct/100*et),K=Math.round((t.paddingPct??0)/100*et),{canvas:j,ctx:n}=ut(r,c);n.imageSmoothingEnabled=!0,n.imageSmoothingQuality="high",t.backgroundColor&&(n.save(),n.fillStyle=t.backgroundColor,n.fillRect(0,0,r,c),n.restore());const _=Math.min(r,c)/2,x=_-Math.max(1,K),P=Math.max(0,x-N),Q=P+1,p=(a.modes?.ring?.colors??[]).map(i=>({color:i,weight:1})),E=p.length,B=t.presentation;let f;if(B==="ring"?f="concentric":B==="segment"?f="angular":B==="cutout"?f="cutout":f="concentric",f==="cutout"){n.save();const i=w.width,D=w.height,T=Q*2,z=1+(t.imageZoom??0)/100,A=t.originalImageDimensions?.width??i,F=t.originalImageDimensions?.height??D;let y;if(t.circleSize&&t.circleSize>0){const g=Math.max(t.circleSize/A,t.circleSize/F)*z,$=T/t.circleSize;y=g*$}else y=Math.max(T/A,T/F)*z;const M=d&&C>0?y/C:y,Z=i*M,R=D*M,W=t.imageOffsetPx?.x??0,V=t.imageOffsetPx?.y??0,I=r/2+W,X=c/2+V;n.drawImage(w,I-Z/2,X-R/2,Z,R),n.globalCompositeOperation="destination-in",n.fillStyle="#ffffff",n.beginPath(),n.arc(I,X,Q,0,Math.PI*2),n.closePath(),n.fill(),n.globalCompositeOperation="source-over",n.restore(),t.onProgress?.(.4);const S=t.flagOffsetPct?.x??0,h=r,u=Math.abs(S/50)*h*3,v=new OffscreenCanvas(r+u,c),l=v.getContext("2d");l.imageSmoothingEnabled=!0,l.imageSmoothingQuality="high";const O=u/2+_;if(t.borderImageBitmap){const k=x*2,g=k,$=a.aspectRatio??2,L=g*$,J=(L-k)/2,tt=-(S/50)*J,at=O-L/2+tt,nt=_-g/2;l.drawImage(t.borderImageBitmap,at,nt,L,g)}else{let k=0;for(const g of p){const L=g.weight/E*c;l.fillStyle=g.color,l.fillRect(0,k,v.width,L),k+=L}}l.globalCompositeOperation="destination-in",l.fillStyle="white",l.beginPath(),l.arc(O,_,x,0,Math.PI*2),l.arc(O,_,P,Math.PI*2,0,!0),l.fill(),n.drawImage(v,-u/2,0)}else{n.save();const i=w.width,D=w.height,T=Q*2,z=1+(t.imageZoom??0)/100,A=t.originalImageDimensions?.width??i,F=t.originalImageDimensions?.height??D;let y;if(t.circleSize&&t.circleSize>0){const h=Math.max(t.circleSize/A,t.circleSize/F)*z,u=T/t.circleSize;y=h*u}else y=Math.max(T/A,T/F)*z;const M=d&&C>0?y/C:y,Z=i*M,R=D*M,W=t.imageOffsetPx?.x??0,V=t.imageOffsetPx?.y??0,I=r/2+W,X=c/2+V;if(n.drawImage(w,I-Z/2,X-R/2,Z,R),n.globalCompositeOperation="destination-in",n.fillStyle="#ffffff",n.beginPath(),n.arc(I,X,Q,0,Math.PI*2),n.closePath(),n.fill(),n.globalCompositeOperation="source-over",n.restore(),t.onProgress?.(.5),t.borderImageBitmap&&B!=="cutout"){const S=Math.max(1,Math.round(x-P)),h=(P+x)/2,v=Math.max(2,Math.round(2*Math.PI*h)),l=S;try{const O=new OffscreenCanvas(v,l),k=O.getContext("2d"),g=t.borderImageBitmap.width,$=t.borderImageBitmap.height,L=Math.max(v/g,l/$),J=Math.round(g*L),tt=Math.round($*L),at=Math.round((v-J)/2),nt=Math.round((l-tt)/2);k.clearRect(0,0,v,l),k.drawImage(t.borderImageBitmap,0,0,g,$,at,nt,J,tt);const it=await createImageBitmap(O),lt=t.segmentRotation!==void 0?t.segmentRotation*Math.PI/180:0,mt=-Math.PI/2+lt;st(n,I,P,x,it,mt,"normal")}catch{try{st(n,I,P,x,t.borderImageBitmap)}catch{n.save(),n.globalAlpha=.64,ot(n,I,P,x,p,E),n.restore()}}}else if(f==="concentric")ot(n,I,P,x,p,E);else{const S=t.segmentRotation!==void 0?t.segmentRotation*Math.PI/180:0;let h=-Math.PI/2+S;for(const u of p){const v=u.weight/E,l=Math.PI*2*v,O=h+l;vt(n,I,P,x,h,O,u.color),h=O}}}s&&o.mark("renderComplete"),t.onProgress?.(.8),t.outerStroke&&(n.beginPath(),n.arc(r/2,c/2,x,0,Math.PI*2),n.strokeStyle=t.outerStroke.color,n.lineWidth=t.outerStroke.widthPx,n.stroke());const b=t.pngQuality??.92,q=await wt(j,"image/png",b),Y=q.size,G=(Y/Mt.BYTES_PER_KB).toFixed(2);if(s){o.mark("exportComplete");const i=o.complete({width:e.width,height:e.height},{width:r,height:c},d,C);return t.onProgress?.(1),{blob:q,sizeBytes:Y,sizeKB:G,metrics:i}}return t.onProgress?.(1),{blob:q,sizeBytes:Y,sizeKB:G}}function ot(e,a,t,o,s,m){const w=o-t;let d=o;for(const C of s){const r=C.weight/m*w,c=Math.max(t,d-r);if(e.beginPath(),e.arc(a,a,d,0,Math.PI*2),e.arc(a,a,c,Math.PI*2,0,!0),e.closePath(),e.fillStyle=C.color,e.fill(),d=c,d<=t+.5)break}d>t+.5&&(e.beginPath(),e.arc(a,a,d,0,Math.PI*2),e.arc(a,a,t,Math.PI*2,0,!0),e.closePath(),e.fillStyle=s[s.length-1]?.color??"#000000",e.fill())}function vt(e,a,t,o,s,m,w){e.beginPath(),e.arc(a,a,o,s,m),e.arc(a,a,t,m,s,!0),e.closePath(),e.fillStyle=w,e.fill()}function st(e,a,t,o,s,m=0,w="normal"){const d=o-t;if(d<=0)return;const C=(t+o)/2,H=Math.max(1,Math.round(2*Math.PI*C)),r=Math.max(1,H),c=Math.max(1,Math.round(d)),N=new OffscreenCanvas(r,c).getContext("2d"),K=s.width,j=s.height,n=Math.max(r/K,c/j),_=Math.round(K*n),x=Math.round(j*n),P=Math.round((r-_)/2),Q=Math.round((c-x)/2);N.clearRect(0,0,r,c),N.drawImage(s,0,0,K,j,P,Q,_,x);const p=N.getImageData(0,0,r,c).data,E=Math.floor(a-o),B=Math.floor(a-o),f=Math.ceil(o*2),b=f,q=new OffscreenCanvas(f,b),Y=q.getContext("2d"),G=Y.createImageData(f,b),i=G.data,D=Math.PI*2,T=1/D;for(let M=0;M<b;M++){const R=B+M+.5-a;for(let W=0;W<f;W++){const I=E+W+.5-a,X=I*I+R*R,S=Math.sqrt(X),h=(M*f+W)*4;if(S<t||S>o){i[h+0]=0,i[h+1]=0,i[h+2]=0,i[h+3]=0;continue}let u=Math.atan2(R,I);for(u-=m;u<0;)u+=D;for(;u>=D;)u-=D;const v=u*T*r,l=(S-t)/d*c,O=Math.min(r-1,Math.max(0,Math.floor(v))),g=(Math.min(c-1,Math.max(0,Math.floor(l)))*r+O)*4;i[h+0]=p[g+0],i[h+1]=p[g+1],i[h+2]=p[g+2],i[h+3]=p[g+3]}}if(Y.putImageData(G,0,0),w==="normal"){e.save(),e.drawImage(q,E,B),e.restore();return}const U=new OffscreenCanvas(f,b),z=U.getContext("2d");z.clearRect(0,0,f,b),z.drawImage(e.canvas,E,B,f,b,0,0,f,b);const A=z.getImageData(0,0,f,b),F=A.data,y=Y.getImageData(0,0,f,b).data;for(let M=0;M<F.length;M+=4)y[M+3]>8&&(F[M+3]=0);z.putImageData(A,0,0),e.save(),e.drawImage(U,E,B),e.restore()}export{bt as I,Pt as R,yt as r};
