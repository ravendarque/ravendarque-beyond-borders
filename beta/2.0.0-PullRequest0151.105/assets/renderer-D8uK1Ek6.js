const lt={chrome:268435456,firefox:1073676289,safari:16777216,default:16777216};function ot(){const e=navigator.userAgent.toLowerCase();return e.includes("chrome")||e.includes("edge")?"chrome":e.includes("firefox")?"firefox":e.includes("safari")&&!e.includes("chrome")?"safari":"default"}function mt(){const e=ot();return lt[e]}function ht(e,a){const t=mt(),n=e*a;if(n>t){const s=ot(),m=Math.floor(Math.sqrt(t));throw new Error(`Canvas size ${e}x${a} (${n.toLocaleString()} pixels) exceeds ${s} limit of ${Math.floor(Math.sqrt(t))}x${Math.floor(Math.sqrt(t))} (${t.toLocaleString()} pixels). Maximum dimension: ${m}px.`)}}function ft(){try{return typeof OffscreenCanvas<"u"&&typeof OffscreenCanvas.prototype.convertToBlob=="function"}catch{return!1}}function dt(e,a){if(ht(e,a),ft()){const t=new OffscreenCanvas(e,a),n=t.getContext("2d");if(!n)throw new Error("Failed to get 2D context from OffscreenCanvas");return{canvas:t,ctx:n}}else{const t=document.createElement("canvas");t.width=e,t.height=a;const n=t.getContext("2d");if(!n)throw new Error("Failed to get 2D context from Canvas");return{canvas:t,ctx:n}}}async function gt(e,a="image/png",t){return e instanceof OffscreenCanvas?e.convertToBlob({type:a,quality:t}):new Promise((n,s)=>{e.toBlob(m=>{m?n(m):s(new Error("Failed to convert canvas to blob"))},a,t)})}const bt={HIGH_RES:1024},vt={DEFAULT_CIRCLE_SIZE:250},ut={BYTES_PER_KB:1024};class wt{startTime=0;marks=new Map;start(){this.startTime=performance.now(),this.marks.clear()}mark(a){this.marks.set(a,performance.now())}elapsed(){return performance.now()-this.startTime}duration(a,t){const n=this.marks.get(a),s=this.marks.get(t);return n===void 0||s===void 0?0:s-n}complete(a,t,n,s){const m=this.elapsed(),g=this.duration("start","imageLoaded"),u=this.duration("imageLoaded","renderComplete"),O=this.duration("renderComplete","exportComplete"),z=a.width*a.height*4,c=t.width*t.height*4,i=z+c;return{totalTime:m,imageLoadTime:g,renderTime:u,exportTime:O,inputSize:a,outputSize:t,wasDownsampled:n,downsampleRatio:s,estimatedMemory:i}}}function Mt(e,a,t,n=2){const s=t*n;if(e<=s&&a<=s)return{width:e,height:a,scale:1};const m=Math.min(s/e,s/a);return{width:Math.round(e*m),height:Math.round(a*m),scale:m}}async function xt(e,a,t){if(e.width===a&&e.height===t)return e;const n=new OffscreenCanvas(a,t),s=n.getContext("2d");if(!s)throw new Error("Failed to get 2D context for downsampling");return s.imageSmoothingEnabled=!0,s.imageSmoothingQuality="high",s.drawImage(e,0,0,a,t),createImageBitmap(n)}function It(e,a,t,n=2){return Math.max(e,a)>t*n}async function yt(e,a,t){const n=new wt,s=t.enablePerformanceTracking??!1;s&&(n.start(),n.mark("start"));const m=t.enableDownsampling??!0;let g=e,u=!1,O=1;if(m&&It(e.width,e.height,t.size)){const l=Mt(e.width,e.height,t.size);g=await xt(e,l.width,l.height),u=!0,O=l.scale,s&&n.mark("imageDownsampled")}s&&n.mark("imageLoaded"),t.onProgress?.(.2);const z=t.size,c=z,i=z,J=Math.min(c,i),Z=Math.round(t.thicknessPct/100*J),q=Math.round((t.paddingPct??0)/100*J),{canvas:N,ctx:o}=dt(c,i);o.imageSmoothingEnabled=!0,o.imageSmoothingQuality="high",t.backgroundColor&&(o.save(),o.fillStyle=t.backgroundColor,o.fillRect(0,0,c,i),o.restore());const f=Math.min(c,i)/2,M=f-Math.max(1,q),P=Math.max(0,M-Z),Y=Ct(P,0,f-.5),y=(a.modes?.ring?.colors??[]).map(l=>({color:l,weight:1})),D=y.length,E=t.presentation;let d;if(E==="ring"?d="concentric":E==="segment"?d="angular":E==="cutout"?d="cutout":d="concentric",d==="cutout"){o.save(),o.beginPath(),o.arc(f,f,Y,0,Math.PI*2),o.closePath(),o.clip();const l=g.width,S=g.height,_=Y*2,X=Math.max(_/l,_/S),Q=1+(t.imageZoom??0)/100,T=X*Q,A=l*T,w=S*T,G=t.imageOffsetPx?.x??0,$=t.imageOffsetPx?.y??0,R=c/2+G,U=i/2+$;o.drawImage(g,R-A/2,U-w/2,A,w),o.restore(),t.onProgress?.(.4);const p=t.flagOffsetPct?.x??0,B=c,b=Math.abs(p/50)*B*3,h=new OffscreenCanvas(c+b,i),r=h.getContext("2d");r.imageSmoothingEnabled=!0,r.imageSmoothingQuality="high";const v=b/2+f;if(t.borderImageBitmap){const k=M*2,I=k,F=a.aspectRatio??2,x=I*F,V=(x-k)/2,j=-(p/50)*V,tt=v-x/2+j,et=f-I/2;r.drawImage(t.borderImageBitmap,tt,et,x,I)}else{let k=0;for(const I of y){const x=I.weight/D*i;r.fillStyle=I.color,r.fillRect(0,k,h.width,x),k+=x}}r.globalCompositeOperation="destination-in",r.fillStyle="white",r.beginPath(),r.arc(v,f,M,0,Math.PI*2),r.arc(v,f,P,Math.PI*2,0,!0),r.fill(),o.drawImage(h,-b/2,0)}else{o.save(),o.beginPath(),o.arc(f,f,Y,0,Math.PI*2),o.closePath(),o.clip();const l=g.width,S=g.height,_=Y*2,X=Math.max(_/l,_/S),Q=1+(t.imageZoom??0)/100,T=X*Q,A=l*T,w=S*T,G=t.imageOffsetPx?.x??0,$=t.imageOffsetPx?.y??0,R=c/2+G,U=i/2+$;if(o.drawImage(g,R-A/2,U-w/2,A,w),o.restore(),t.onProgress?.(.5),t.borderImageBitmap&&E!=="cutout"){const p=Math.max(1,Math.round(M-P)),B=(P+M)/2,h=Math.max(2,Math.round(2*Math.PI*B)),r=p;try{const v=new OffscreenCanvas(h,r),k=v.getContext("2d"),I=t.borderImageBitmap.width,F=t.borderImageBitmap.height,x=Math.max(h/I,r/F),V=Math.round(I*x),j=Math.round(F*x),tt=Math.round((h-V)/2),et=Math.round((r-j)/2);k.clearRect(0,0,h,r),k.drawImage(t.borderImageBitmap,0,0,I,F,tt,et,V,j);const rt=await createImageBitmap(v),ct=t.segmentRotation!==void 0?t.segmentRotation*Math.PI/180:0,it=-Math.PI/2+ct;nt(o,f,P,M,rt,it,"normal")}catch{try{nt(o,f,P,M,t.borderImageBitmap)}catch{o.save(),o.globalAlpha=.64,at(o,f,P,M,y,D),o.restore()}}}else if(d==="concentric")at(o,f,P,M,y,D);else{const p=t.segmentRotation!==void 0?t.segmentRotation*Math.PI/180:0;let B=-Math.PI/2+p;for(const b of y){const h=b.weight/D,r=Math.PI*2*h,v=B+r;Pt(o,f,P,M,B,v,b.color),B=v}}}s&&n.mark("renderComplete"),t.onProgress?.(.8),t.outerStroke&&(o.beginPath(),o.arc(c/2,i/2,M,0,Math.PI*2),o.strokeStyle=t.outerStroke.color,o.lineWidth=t.outerStroke.widthPx,o.stroke());const C=t.pngQuality??.92,W=await gt(N,"image/png",C),L=W.size,K=(L/ut.BYTES_PER_KB).toFixed(2);if(s){n.mark("exportComplete");const l=n.complete({width:e.width,height:e.height},{width:c,height:i},u,O);return t.onProgress?.(1),{blob:W,sizeBytes:L,sizeKB:K,metrics:l}}return t.onProgress?.(1),{blob:W,sizeBytes:L,sizeKB:K}}function at(e,a,t,n,s,m){const g=n-t;let u=n;for(const O of s){const c=O.weight/m*g,i=Math.max(t,u-c);if(e.beginPath(),e.arc(a,a,u,0,Math.PI*2),e.arc(a,a,i,Math.PI*2,0,!0),e.closePath(),e.fillStyle=O.color,e.fill(),u=i,u<=t+.5)break}u>t+.5&&(e.beginPath(),e.arc(a,a,u,0,Math.PI*2),e.arc(a,a,t,Math.PI*2,0,!0),e.closePath(),e.fillStyle=s[s.length-1]?.color??"#000000",e.fill())}function Pt(e,a,t,n,s,m,g){e.beginPath(),e.arc(a,a,n,s,m),e.arc(a,a,t,m,s,!0),e.closePath(),e.fillStyle=g,e.fill()}function Ct(e,a,t){return Math.min(Math.max(e,a),t)}function nt(e,a,t,n,s,m=0,g="normal"){const u=n-t;if(u<=0)return;const O=(t+n)/2,z=Math.max(1,Math.round(2*Math.PI*O)),c=Math.max(1,z),i=Math.max(1,Math.round(u)),Z=new OffscreenCanvas(c,i).getContext("2d"),q=s.width,N=s.height,o=Math.max(c/q,i/N),f=Math.round(q*o),M=Math.round(N*o),P=Math.round((c-f)/2),Y=Math.round((i-M)/2);Z.clearRect(0,0,c,i),Z.drawImage(s,0,0,q,N,P,Y,f,M);const y=Z.getImageData(0,0,c,i).data,D=Math.floor(a-n),E=Math.floor(a-n),d=Math.ceil(n*2),C=d,W=new OffscreenCanvas(d,C),L=W.getContext("2d"),K=L.createImageData(d,C),l=K.data,S=Math.PI*2,_=1/S;for(let w=0;w<C;w++){const $=E+w+.5-a;for(let R=0;R<d;R++){const p=D+R+.5-a,B=p*p+$*$,b=Math.sqrt(B),h=(w*d+R)*4;if(b<t||b>n){l[h+0]=0,l[h+1]=0,l[h+2]=0,l[h+3]=0;continue}let r=Math.atan2($,p);for(r-=m;r<0;)r+=S;for(;r>=S;)r-=S;const v=r*_*c,k=(b-t)/u*i,I=Math.min(c-1,Math.max(0,Math.floor(v))),x=(Math.min(i-1,Math.max(0,Math.floor(k)))*c+I)*4;l[h+0]=y[x+0],l[h+1]=y[x+1],l[h+2]=y[x+2],l[h+3]=y[x+3]}}if(L.putImageData(K,0,0),g==="normal"){e.save(),e.drawImage(W,D,E),e.restore();return}const X=new OffscreenCanvas(d,C),H=X.getContext("2d");H.clearRect(0,0,d,C),H.drawImage(e.canvas,D,E,d,C,0,0,d,C);const Q=H.getImageData(0,0,d,C),T=Q.data,A=L.getImageData(0,0,d,C).data;for(let w=0;w<T.length;w+=4)A[w+3]>8&&(T[w+3]=0);H.putImageData(Q,0,0),e.save(),e.drawImage(X,D,E),e.restore()}export{vt as I,bt as R,yt as r};
